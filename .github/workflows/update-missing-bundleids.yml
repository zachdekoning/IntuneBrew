name: Update Missing BundleIDs

on:
  workflow_dispatch:
  schedule:
    - cron: "0 0 * * 0" # Run weekly at midnight on Sunday

jobs:
  update-bundleids:
    runs-on: macos-latest
    permissions:
      contents: write # This gives the job permission to write to the repository

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.PAT }}

      - name: Verify repository checkout
        run: |
          echo "Verifying repository checkout..."
          echo "Current directory: $(pwd)"
          echo "Repository contents:"
          ls -la

          if [ ! -d "Apps" ]; then
            echo "‚ùå Apps directory not found!"
            echo "Creating Apps directory for testing..."
            mkdir -p Apps
            
            # Create a test JSON file for macdown
            echo '{
              "name": "MacDown",
              "description": "Open-source Markdown editor",
              "version": "0.7.2",
              "url": "https://intunebrew.blob.core.windows.net/pkg/macdown_0.7.2.pkg",
              "bundleId": null,
              "homepage": "https://macdown.uranusjr.com/",
              "fileName": "macdown_0.7.2.pkg",
              "type": "app",
              "sha": "bba030fc49d9dd7ab0c139fe5c39773eff0830336d6ab06b6fa7b23621efe774",
              "previous_version": "0.7.2"
            }' > Apps/macdown.json
            
            echo "Created test file: Apps/macdown.json"
          else
            echo "‚úÖ Apps directory found"
            echo "Apps directory contents:"
            ls -la Apps/
          fi

      - name: Find apps with missing bundleIds
        id: find-apps
        run: |
          echo "Finding apps with missing bundleIds..."

          # Create an array to store apps with missing bundleIds
          APPS_TO_PROCESS=()

          # Create arrays to track missing, processed, and skipped files
          MISSING_FILES=()
          PROCESSED_FILES=()
          SKIPPED_APPS=()

          # List all files in the Apps directory for debugging
          echo "Listing all files in Apps directory:"
          ls -la Apps/

          # Loop through all JSON files in the Apps directory (case-insensitive)
          shopt -s nocaseglob  # Enable case-insensitive globbing
          for APP_JSON_PATH in Apps/*.json; do
            # Check if file exists
            if [ ! -f "$APP_JSON_PATH" ]; then
              echo "Warning: $APP_JSON_PATH does not exist, adding to missing files list"
              MISSING_FILES+=("$APP_JSON_PATH")
              continue
            fi
            
            echo "Processing JSON file: $APP_JSON_PATH"
            
            # Validate JSON file
            echo "Validating JSON file: $APP_JSON_PATH"
            if ! jq empty "$APP_JSON_PATH" 2>/dev/null; then
              echo "‚ùå Invalid JSON in $APP_JSON_PATH, skipping"
              continue
            fi
            
            # Extract app name from filename
            APP_NAME=$(basename "$APP_JSON_PATH" .json)
            
            # Check if bundleId is null or empty
            BUNDLE_ID=$(jq -r '.bundleId' "$APP_JSON_PATH" 2>/dev/null)
            if [ $? -ne 0 ]; then
              echo "Warning: Failed to parse $APP_JSON_PATH, skipping"
              continue
            fi
            
            # Check if required fields exist
            APP_NAME_FROM_JSON=$(jq -r '.name' "$APP_JSON_PATH" 2>/dev/null)
            APP_URL=$(jq -r '.url' "$APP_JSON_PATH" 2>/dev/null)
            
            if [ -z "$APP_NAME_FROM_JSON" ] || [ "$APP_NAME_FROM_JSON" = "null" ] || [ -z "$APP_URL" ] || [ "$APP_URL" = "null" ]; then
              echo "‚ùå Missing required fields in $APP_JSON_PATH, skipping"
              echo "  name: $APP_NAME_FROM_JSON"
              echo "  url: $APP_URL"
              continue
            fi
            
            if [ "$BUNDLE_ID" = "null" ] || [ -z "$BUNDLE_ID" ]; then
              echo "Found app with missing bundleId: $APP_NAME"
              APPS_TO_PROCESS+=("$APP_JSON_PATH")
            fi
          done

          # Save the list of apps to process
          echo "APPS_COUNT=${#APPS_TO_PROCESS[@]}" >> $GITHUB_ENV

          if [ ${#APPS_TO_PROCESS[@]} -eq 0 ]; then
            echo "No apps with missing bundleIds found."
            echo "APPS_TO_PROCESS=" >> $GITHUB_ENV
          else
            # Convert array to newline-separated string and save to a file
            printf "%s\n" "${APPS_TO_PROCESS[@]}" > /tmp/apps_to_process.txt
            echo "Found ${#APPS_TO_PROCESS[@]} apps with missing bundleIds."
          fi

      - name: Process apps with missing bundleIds
        if: env.APPS_COUNT != '0'
        run: |
          echo "Processing ${APPS_COUNT} apps with missing bundleIds..."

          # Initialize a flag to track if any changes were made
          echo "CHANGES_MADE=false" >> $GITHUB_ENV

          # Process each app from the file
          while IFS= read -r APP_JSON_PATH || [ -n "$APP_JSON_PATH" ]; do
            echo "==============================================="
            echo "Processing $APP_JSON_PATH"
            
            # Read app details from JSON
            APP_JSON=$(cat "$APP_JSON_PATH")
            APP_NAME=$(echo "$APP_JSON" | jq -r '.name')
            APP_URL=$(echo "$APP_JSON" | jq -r '.url')
            APP_VERSION=$(echo "$APP_JSON" | jq -r '.version')
            APP_SHA=$(echo "$APP_JSON" | jq -r '.sha')
            
            echo "App Name: $APP_NAME"
            echo "Version: $APP_VERSION"
            echo "URL: $APP_URL"
            
            # Create a temporary directory for this app
            TEMP_DIR="temp_${APP_NAME// /_}"
            mkdir -p "$TEMP_DIR"
            cd "$TEMP_DIR"
            
            # Download with generic name first
            DOWNLOAD_PATH="downloaded_file"
            echo "üì• Downloading $APP_NAME from $APP_URL..."
            curl -L -o "$DOWNLOAD_PATH" "$APP_URL"
            
            if [ $? -ne 0 ]; then
              echo "‚ùå Failed to download file"
              cd ..
              rm -rf "$TEMP_DIR"
              continue
            fi
            
            # Determine file type based on content
            echo "üîç Detecting file type..."
            FILE_TYPE="unknown"
            
            # Check file signature/magic bytes
            FILE_INFO=$(file "$DOWNLOAD_PATH")
            echo "File info: $FILE_INFO"
            
            if [[ "$FILE_INFO" == *"Zip archive"* ]]; then
              FILE_TYPE="zip"
              mv "$DOWNLOAD_PATH" "app_package.zip"
              DOWNLOAD_PATH="app_package.zip"
              echo "Detected ZIP file"
            elif [[ "$FILE_INFO" == *"xar archive"* ]] || [[ "$FILE_INFO" == *"installer"* ]] || [[ "$FILE_INFO" == *"package"* ]]; then
              FILE_TYPE="pkg"
              mv "$DOWNLOAD_PATH" "app_package.pkg"
              DOWNLOAD_PATH="app_package.pkg"
              echo "Detected PKG file"
            elif [[ "$FILE_INFO" == *"disk image"* ]] || [[ "$FILE_INFO" == *"DMG"* ]]; then
              FILE_TYPE="dmg"
              mv "$DOWNLOAD_PATH" "app_package.dmg"
              DOWNLOAD_PATH="app_package.dmg"
              echo "Detected DMG file"
            else
              # Fallback to URL-based detection if content detection fails
              if [[ "$APP_URL" == *".dmg" ]]; then
                FILE_TYPE="dmg"
                mv "$DOWNLOAD_PATH" "app_package.dmg"
                DOWNLOAD_PATH="app_package.dmg"
              elif [[ "$APP_URL" == *".zip" ]]; then
                FILE_TYPE="zip"
                mv "$DOWNLOAD_PATH" "app_package.zip"
                DOWNLOAD_PATH="app_package.zip"
              elif [[ "$APP_URL" == *".pkg" ]]; then
                FILE_TYPE="pkg"
                mv "$DOWNLOAD_PATH" "app_package.pkg"
                DOWNLOAD_PATH="app_package.pkg"
              else
                # Default to pkg if we can't determine
                FILE_TYPE="pkg"
                mv "$DOWNLOAD_PATH" "app_package.pkg"
                DOWNLOAD_PATH="app_package.pkg"
              fi
              echo "Using URL-based detection: $FILE_TYPE"
            fi
            
            echo "File type determined: $FILE_TYPE"
            
            # Verify SHA256 checksum if provided
            if [ -n "$APP_SHA" ] && [ "$APP_SHA" != "null" ]; then
              echo "üîê Verifying SHA256 checksum..."
              DOWNLOADED_SHA=$(shasum -a 256 "$DOWNLOAD_PATH" | awk '{print $1}')
              echo "Expected: $APP_SHA"
              echo "Actual: $DOWNLOADED_SHA"
              
              if [ "$DOWNLOADED_SHA" = "$APP_SHA" ]; then
                echo "‚úÖ SHA256 checksum verified successfully"
              else
                echo "‚ùå SHA256 checksum verification failed"
                continue
              fi
            fi
            
            # Install the app based on file type
            if [ "$FILE_TYPE" = "pkg" ]; then
              # Install PKG file
              echo "üì¶ Installing $APP_NAME from PKG..."
              sudo installer -pkg app_package.pkg -target /
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Installation failed"
                continue
              fi
              
              echo "‚úÖ Installation successful"
            fi
            
            if [ "$FILE_TYPE" = "dmg" ]; then
              # Mount DMG file
              echo "üíø Mounting DMG file..."
              MOUNT_POINT="/Volumes/AppDMG"
              hdiutil attach -mountpoint "$MOUNT_POINT" app_package.dmg -nobrowse
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Failed to mount DMG file"
                continue
              fi
              
              # Find the .app file in the mounted DMG
              echo "üîç Finding .app in DMG..."
              DMG_APP=$(find "$MOUNT_POINT" -maxdepth 1 -name "*.app" | head -1)
              
              if [ -z "$DMG_APP" ]; then
                echo "‚ùå Could not find .app file in DMG"
                hdiutil detach "$MOUNT_POINT" -force
                continue
              fi
              
              echo "üìÇ Found app: $DMG_APP"
              
              # Copy the app to Applications folder
              echo "üìã Copying app to Applications folder..."
              cp -R "$DMG_APP" /Applications/
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Failed to copy app to Applications folder"
                hdiutil detach "$MOUNT_POINT" -force
                continue
              fi
              
              echo "‚úÖ App copied successfully"
              
              # Unmount the DMG
              echo "üíø Unmounting DMG..."
              hdiutil detach "$MOUNT_POINT" -force
            fi
            
            if [ "$FILE_TYPE" = "zip" ]; then
              # Extract ZIP file
              echo "üì¶ Extracting ZIP file..."
              EXTRACT_DIR="app_extracted"
              mkdir -p "$EXTRACT_DIR"
              unzip -q app_package.zip -d "$EXTRACT_DIR"
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Failed to extract ZIP file"
                continue
              fi
              
              # Find the .app file in the extracted contents
              echo "üîç Finding .app in extracted contents..."
              ZIP_APP=$(find "$EXTRACT_DIR" -name "*.app" -type d | head -1)
              
              if [ -z "$ZIP_APP" ]; then
                echo "‚ùå Could not find .app file in ZIP contents"
                rm -rf "$EXTRACT_DIR"
                continue
              fi
              
              echo "üìÇ Found app: $ZIP_APP"
              
              # Copy the app to Applications folder
              echo "üìã Copying app to Applications folder..."
              cp -R "$ZIP_APP" /Applications/
              
              if [ $? -ne 0 ]; then
                echo "‚ùå Failed to copy app to Applications folder"
                rm -rf "$EXTRACT_DIR"
                continue
              fi
              
              echo "‚úÖ App copied successfully"
              
              # Clean up extracted files
              echo "üßπ Cleaning up extracted files..."
              rm -rf "$EXTRACT_DIR"
            fi
            
            # Find the app in Applications folder
            echo "üîç Finding app in Applications folder..."
            
            # Get the app name from the JSON file for more accurate matching
            JSON_APP_NAME=$(echo "$APP_JSON" | jq -r '.name')
            echo "App name from JSON: $JSON_APP_NAME"
            
            # Create a normalized version of the app name (lowercase, no special chars)
            NORMALIZED_APP_NAME=$(echo "$JSON_APP_NAME" | tr '[:upper:]' '[:lower:]' | tr -d '[:punct:]' | tr '√∂√§√º√ñ√Ñ√ú' 'oauOAU')
            echo "Normalized app name: $NORMALIZED_APP_NAME"
            
            # List all apps and save to a file
            find /Applications -maxdepth 1 -name "*.app" > /tmp/all_apps.txt
            echo "Available apps in Applications folder:"
            cat /tmp/all_apps.txt
            
            # Try different search strategies to find the app
            APP_PATH=""
            
            # Strategy 1: Direct match with app name
            APP_PATH=$(find /Applications -maxdepth 1 -name "*.app" | grep -i "$JSON_APP_NAME" || echo "")
            if [ -n "$APP_PATH" ]; then
              echo "Found app using direct match: $JSON_APP_NAME"
            fi
            
            # Strategy 2: Try with normalized app name
            if [ -z "$APP_PATH" ]; then
              for APP in $(cat /tmp/all_apps.txt); do
                APP_BASENAME=$(basename "$APP" .app | tr '[:upper:]' '[:lower:]' | tr -d '[:punct:]' | tr '√∂√§√º√ñ√Ñ√ú' 'oauOAU')
                if [[ "$APP_BASENAME" == *"$NORMALIZED_APP_NAME"* ]] || [[ "$NORMALIZED_APP_NAME" == *"$APP_BASENAME"* ]]; then
                  APP_PATH="$APP"
                  echo "Found app using normalized name match: $APP_BASENAME"
                  break
                fi
              done
            fi
            
            # Strategy 3: If not found, try with parts of the name (for apps with spaces)
            if [ -z "$APP_PATH" ]; then
              echo "Normalized match not found, trying with parts of the name..."
              # Split app name by spaces and search for each part
              for WORD in $JSON_APP_NAME; do
                if [ ${#WORD} -gt 3 ]; then  # Only use words longer than 3 characters
                  NORMALIZED_WORD=$(echo "$WORD" | tr '[:upper:]' '[:lower:]' | tr -d '[:punct:]' | tr '√∂√§√º√ñ√Ñ√ú' 'oauOAU')
                  for APP in $(cat /tmp/all_apps.txt); do
                    APP_BASENAME=$(basename "$APP" .app | tr '[:upper:]' '[:lower:]' | tr -d '[:punct:]' | tr '√∂√§√º√ñ√Ñ√ú' 'oauOAU')
                    if [[ "$APP_BASENAME" == *"$NORMALIZED_WORD"* ]]; then
                      APP_PATH="$APP"
                      echo "Found app using partial word match: $WORD -> $APP_BASENAME"
                      break 2
                    fi
                  done
                fi
              done
            fi
            
            # Strategy 4: Try to find a match based on the JSON filename
            if [ -z "$APP_PATH" ]; then
              echo "Word match not found, trying filename match..."
              APP_FILENAME=$(basename "$APP_JSON_PATH" .json | tr '[:upper:]' '[:lower:]' | tr -d '[:punct:]' | tr '√∂√§√º√ñ√Ñ√ú' 'oauOAU')
              
              for APP in $(cat /tmp/all_apps.txt); do
                APP_BASENAME=$(basename "$APP" .app | tr '[:upper:]' '[:lower:]' | tr -d '[:punct:]' | tr '√∂√§√º√ñ√Ñ√ú' 'oauOAU')
                if [[ "$APP_BASENAME" == *"$APP_FILENAME"* ]] || [[ "$APP_FILENAME" == *"$APP_BASENAME"* ]]; then
                  APP_PATH="$APP"
                  echo "Found app using filename match: $APP_FILENAME -> $APP_BASENAME"
                  break
                fi
              done
            fi
            
            if [ -z "$APP_PATH" ]; then
              echo "‚ö†Ô∏è Could not find app in Applications folder"
              echo "Available apps:"
              ls -la /Applications
              echo "Skipping this app as it doesn't have a .app file in Applications folder"
              
              # Add to skipped apps list for summary
              SKIPPED_APPS+=("$APP_JSON_PATH - No .app file found")
              continue
            fi
            
            # Skip app details and bundleId extraction for CLI tools
            echo "üìÇ App path: $APP_PATH"
            
            # Print app details for debugging
            echo "üìã App details:"
            ls -la "$APP_PATH"
            echo "App bundle contents:"
            ls -la "$APP_PATH/Contents" || echo "Could not access Contents directory"
            
            # Get app bundle ID using multiple methods
            echo "üîç Extracting bundleId..."
            
            # Method 1: Using mdls
            echo "Trying mdls method..."
            ACTUAL_BUNDLE_ID=$(mdls -name kMDItemCFBundleIdentifier -raw "$APP_PATH" 2>/dev/null || echo "Not found")
            echo "mdls result: $ACTUAL_BUNDLE_ID"
            
            # Method 2: Using PlistBuddy
            if [ "$ACTUAL_BUNDLE_ID" = "Not found" ] || [ "$ACTUAL_BUNDLE_ID" = "(null)" ]; then
              echo "Trying PlistBuddy method..."
              if [ -f "$APP_PATH/Contents/Info.plist" ]; then
                ACTUAL_BUNDLE_ID=$(/usr/libexec/PlistBuddy -c "Print :CFBundleIdentifier" "$APP_PATH/Contents/Info.plist" 2>/dev/null || echo "Not found")
                echo "PlistBuddy result: $ACTUAL_BUNDLE_ID"
              else
                echo "Info.plist not found at expected location"
              fi
            fi
            
            # Method 3: Using defaults command
            if [ "$ACTUAL_BUNDLE_ID" = "Not found" ] || [ "$ACTUAL_BUNDLE_ID" = "(null)" ]; then
              echo "Trying defaults command method..."
              if [ -f "$APP_PATH/Contents/Info.plist" ]; then
                ACTUAL_BUNDLE_ID=$(defaults read "$APP_PATH/Contents/Info" CFBundleIdentifier 2>/dev/null || echo "Not found")
                echo "defaults command result: $ACTUAL_BUNDLE_ID"
              fi
            fi
            
            # Method 4: Using grep on the Info.plist file
            if [ "$ACTUAL_BUNDLE_ID" = "Not found" ] || [ "$ACTUAL_BUNDLE_ID" = "(null)" ]; then
              echo "Trying grep method..."
              if [ -f "$APP_PATH/Contents/Info.plist" ]; then
                # Extract the line with CFBundleIdentifier and the value after it
                BUNDLE_ID_LINE=$(grep -A1 "CFBundleIdentifier" "$APP_PATH/Contents/Info.plist" | grep -v "CFBundleIdentifier" | grep -o ">.*<" | sed 's/>//;s/<//g')
                if [ -n "$BUNDLE_ID_LINE" ]; then
                  ACTUAL_BUNDLE_ID="$BUNDLE_ID_LINE"
                  echo "grep method result: $ACTUAL_BUNDLE_ID"
                fi
              fi
            fi
            
            echo "üÜî Extracted Bundle ID: $ACTUAL_BUNDLE_ID"
            
            # Update the JSON file if a valid bundleId was found
            if [ "$ACTUAL_BUNDLE_ID" != "Not found" ] && [ "$ACTUAL_BUNDLE_ID" != "(null)" ]; then
              echo "üîÑ Updating bundleId in JSON file..."
              
              # Get absolute path to the JSON file
              ABSOLUTE_JSON_PATH="$GITHUB_WORKSPACE/$APP_JSON_PATH"
              echo "JSON file path: $ABSOLUTE_JSON_PATH"
              
              # Verify the JSON file exists
              if [ ! -f "$ABSOLUTE_JSON_PATH" ]; then
                echo "‚ùå JSON file not found at $ABSOLUTE_JSON_PATH"
                echo "Current directory: $(pwd)"
                echo "Listing workspace directory:"
                ls -la "$GITHUB_WORKSPACE"
                echo "Listing Apps directory:"
                ls -la "$GITHUB_WORKSPACE/Apps" || echo "Apps directory not found"
                continue
              fi
              
              # Create a backup of the original file
              cp "$ABSOLUTE_JSON_PATH" "${ABSOLUTE_JSON_PATH}.bak"
              
              # Update the bundleId in the JSON file using jq
              jq --arg new_bundle_id "$ACTUAL_BUNDLE_ID" '.bundleId = $new_bundle_id' "$ABSOLUTE_JSON_PATH" > "${ABSOLUTE_JSON_PATH}.tmp"
              mv "${ABSOLUTE_JSON_PATH}.tmp" "$ABSOLUTE_JSON_PATH"
              
              echo "‚úÖ Updated bundleId in $ABSOLUTE_JSON_PATH to '$ACTUAL_BUNDLE_ID'"
              echo "CHANGES_MADE=true" >> $GITHUB_ENV
            else
              echo "‚ö†Ô∏è Could not extract a valid bundleId"
            fi
            
            # Clean up the temporary directory
            cd "$GITHUB_WORKSPACE"
            rm -rf "$TEMP_DIR"
            
            echo "==============================================="
            
            # Add to processed files list
            PROCESSED_FILES+=("$APP_JSON_PATH")
          done < /tmp/apps_to_process.txt

          # Save the lists to environment variables for the summary step
          echo "MISSING_FILES_COUNT=${#MISSING_FILES[@]}" >> $GITHUB_ENV
          echo "PROCESSED_FILES_COUNT=${#PROCESSED_FILES[@]}" >> $GITHUB_ENV
          echo "SKIPPED_APPS_COUNT=${#SKIPPED_APPS[@]}" >> $GITHUB_ENV

          # Save missing files to a file for the summary step
          if [ ${#MISSING_FILES[@]} -gt 0 ]; then
            printf "%s\n" "${MISSING_FILES[@]}" > /tmp/missing_files.txt
          fi

          # Save skipped apps to a file for the summary step
          if [ ${#SKIPPED_APPS[@]} -gt 0 ]; then
            printf "%s\n" "${SKIPPED_APPS[@]}" > /tmp/skipped_apps.txt
          fi

      - name: Commit and push changes
        if: env.CHANGES_MADE == 'true'
        run: |
          echo "üìù Committing bundleId changes to repository..."
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Check if there are changes to commit
          if git diff --quiet -- "Apps/"; then
            echo "No changes to commit"
          else
            echo "Changes detected, committing..."
            git add "Apps/"
            git commit -m "Update missing bundleIds for apps"
            
            # Push using the PAT for authentication
            echo "Pushing changes to repository..."
            git push https://${{ secrets.PAT }}@github.com/${{ github.repository }}.git
            
            if [ $? -eq 0 ]; then
              echo "‚úÖ Successfully pushed changes to repository"
            else
              echo "‚ùå Failed to push changes to repository"
              echo "Trying alternative push method..."
              git push
            fi
          fi

      - name: Output summary
        run: |
          # Create a summary for GitHub Actions
          echo "## BundleID Update Results" >> $GITHUB_STEP_SUMMARY
          echo "| Metric | Value |" >> $GITHUB_STEP_SUMMARY
          echo "| --- | --- |" >> $GITHUB_STEP_SUMMARY
          echo "| Apps Processed | $APPS_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "| Changes Made | $CHANGES_MADE |" >> $GITHUB_STEP_SUMMARY
          echo "| Missing Files | $MISSING_FILES_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "| Skipped Apps | $SKIPPED_APPS_COUNT |" >> $GITHUB_STEP_SUMMARY
          echo "| Successfully Processed | $PROCESSED_FILES_COUNT |" >> $GITHUB_STEP_SUMMARY

          # Add missing files section if any
          if [ -f "/tmp/missing_files.txt" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Missing JSON Files" >> $GITHUB_STEP_SUMMARY
            echo "The following JSON files were not found and need to be fixed manually:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "```" >> $GITHUB_STEP_SUMMARY
            cat /tmp/missing_files.txt >> $GITHUB_STEP_SUMMARY
            echo "```" >> $GITHUB_STEP_SUMMARY
          fi

          # Add skipped apps section if any
          if [ -f "/tmp/skipped_apps.txt" ]; then
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "## Skipped Apps" >> $GITHUB_STEP_SUMMARY
            echo "The following apps were skipped because they don't have a .app file in the Applications folder:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "```" >> $GITHUB_STEP_SUMMARY
            cat /tmp/skipped_apps.txt >> $GITHUB_STEP_SUMMARY
            echo "```" >> $GITHUB_STEP_SUMMARY
          fi

          if [ "$CHANGES_MADE" = "true" ]; then
            echo "The following apps had their bundleIds updated:" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            
            # List all modified JSON files
            git diff --name-only -- "Apps/" | while read -r file; do
              app_name=$(basename "$file" .json)
              bundle_id=$(jq -r '.bundleId' "$file")
              echo "- $app_name: $bundle_id" >> $GITHUB_STEP_SUMMARY
            done
          fi
